# Configuration for Stock MMU2S
# Pat Erley paerley@gmail.com
# More info: ... someday
#
# config inspired from https://github.com/KevinOConnor/klipper/blob/master/config/sample-mmu2s-diy.cfg
# with firmware modifications based on the work of Trevor Jones (tjones141@gmail.com)

# The stock mmu2s board will not work with power from usb+24v alone.  You must also provide
# 5v to pin 1 of the 'serial' header (p1).
[mcu mmu2]
serial: /dev/serial/by-id/usb-Klipper_atmega32u4_12345-if00

[respond]
default_type: command

# Tuning Values used from Stock firmware
#  https://github.com/prusa3d/MM-control-01
#
# stepper current values are in:
#  MM-control-01/config.h
#
# driver_* values are translated from
#  MM-control-01/tmc2130.c
#
# When translating the values, for run current values greater than 31, you must divide by 2 and set rndtf,
# chm, and vsense to 0, as well as dividing the hold current by 2.
#
# To convert from the register value (0-127) to the current:
# Current = (Stock) * Vref / (32 * sense_resistor * sqrt(2))
# Vref is 0.32(run and hold > 16) or 0.16 (run or hold <= 16), and our sense resistor is 0.220, leading to:
#
# run & hold > 16
# Current = Stock/2 * 0.03214121732
# run | hold < 16
# Current = Stock * 0.01607060866
#
# Truncate to 3 decimals and add 1 to the 1000ths place to make sure it rounds up when going back

# MMU2S Board U5 (AX_PUL 0)
[tmc2130 manual_stepper gear_stepper]
cs_pin: mmu2:PC6 # D5
spi_bus: spi
diag1_pin: ^!mmu2:PF4 # A3
driver_SGT: 1 
interpolate: true
# Normal run current 30
run_current: 0.483
# Stealth run current 35
# stealth_current: 0.563
# Normal hold current 1
hold_current: 0.017
# Stealth hold current 1
# stealth_hold_current: 0.017
sense_resistor: 0.220
# These are the tuning values for stealthchop
#driver_IHOLDDELAY: 8
#driver_TPOWERDOWN: 0
#driver_TBL: 2
#driver_TOFF: 3
#driver_HEND: 1
#driver_HSTRT: 5
#driver_PWM_AUTOSCALE: True
#driver_PWM_FREQ: 2
#driver_PWM_GRAD: 6
#driver_PWM_AMPL: 210

[manual_stepper gear_stepper]
step_pin: mmu2:PB4 # D8
dir_pin: !mmu2:SR0 # U2-Q0
enable_pin: !mmu2:SR1 # U2-Q1
microsteps: 16
rotation_distance: 22.857
endstop_pin: !mmu2:PF6 

# MMU2S Board U6 (AX_SEL 1)
[tmc2130 manual_stepper selector_stepper]
cs_pin: mmu2:PD7 # D6
spi_bus: spi
diag1_pin: ^!mmu2:PF1 # A4
driver_SGT: 11 
interpolate: true
# Normal current 35
run_current: 0.563
# Stealth current 35
# stealth_run_current: 0.563
# Normal current 10
hold_current: 0.160
# Stealth current 7
# stealth_hold_current: 0.112
sense_resistor: 0.220
# These are the tuning values for stealthchop
#driver_IHOLDDELAY: 8
#driver_TPOWERDOWN: 0
#driver_TBL: 2
#driver_TOFF: 3
#driver_HEND: 1
#driver_HSTRT: 5
#driver_PWM_AUTOSCALE: True
#driver_PWM_FREQ: 2
#driver_PWM_GRAD: 6
#driver_PWM_AMPL: 210

[manual_stepper selector_stepper]
step_pin: mmu2:PD4 # D4
dir_pin: !mmu2:SR2 # U2-Q2
enable_pin: !mmu2:SR3 # U2-Q3
microsteps: 16
rotation_distance: 8
velocity: 10
accel: 10 
endstop_pin: tmc2130_selector_stepper:virtual_endstop
#position_endstop: 0
#homing_speed: 5
#homing_retract_dist: 1

# MMU2S Board U7 (AX_IDL 2)
[tmc2130 manual_stepper idler_stepper]
cs_pin: mmu2:PB7 # D11
spi_bus: spi
diag1_pin: ^!mmu2:PF0 # A5
interpolate: false
driver_SGT: 16
# The stock values are 'wrong' when using klipper.  The stock firmware
# handles this situation differently.  To attempt to use the 'stock'
# settings, run_current should be 1.512 and hold current should be
# 0.708
# Normal current 47
run_current: 0.756
# Stealth current 45
# Normal current 22
hold_current: 0.354
# Stealth current 22
sense_resistor: 0.220
#driver_IHOLDDELAY: 8
#driver_TPOWERDOWN: 0
# These are the tuning values for stealthchop
#driver_TBL: 2
#driver_TOFF: 3
#driver_HEND: 1
#driver_HSTRT: 5
#driver_PWM_AUTOSCALE: True
#driver_PWM_FREQ: 2
#driver_PWM_GRAD: 6
#driver_PWM_AMPL: 210

[manual_stepper idler_stepper]
step_pin: mmu2:PD6 # D12
dir_pin: mmu2:SR4 # U2-Q4
enable_pin: !mmu2:SR5 # U2-Q5
microsteps: 32
rotation_distance: 360
velocity: 80
accel: 80
endstop_pin: tmc2130_idler_stepper:virtual_endstop


[gcode_button mot_vin]
pin: mmu2:PF7
analog_range: 2.0,5.0
analog_pullup_resistor: 4700
press_gcode:
    RAINBOW
#release_gcode:

[delayed_gcode init_mmu2s]
initial_duration: 1.0
gcode:
    RAINBOW
    UPDATE_STATE 

[gcode_macro VARS_MMU2]
# Selectors are spaced 14mm on stock
variable_selector_positions = [17,31,45,59,73]
variable_idler_positions = [57,95,136,177,218]
# 5 = Unknown, -1 = homed
variable_selector_target = 5
variable_selector_index = 5
variable_idler_target = 5
variable_idler_index = 5
# -1 file_not_found, 0 false, 1 true
variable_filament_loaded = -1
gcode:

[gcode_macro S_S_T]
gcode:
    SET_GCODE_VARIABLE MACRO=VARS_MMU2 VARIABLE=selector_target VALUE={params.VALUE|int}

[gcode_macro S_S_I]
gcode:
    SET_GCODE_VARIABLE MACRO=VARS_MMU2 VARIABLE=selector_index VALUE={params.VALUE|int}

[gcode_macro S_I_T]
gcode:
    SET_GCODE_VARIABLE MACRO=VARS_MMU2 VARIABLE=idler_target VALUE={params.VALUE|int}

[gcode_macro S_I_I]
gcode:
    SET_GCODE_VARIABLE MACRO=VARS_MMU2 VARIABLE=idler_index VALUE={params.VALUE|int}

[gcode_macro S_F_L]
gcode:
    SET_GCODE_VARIABLE MACRO=VARS_MMU2 VARIABLE=filament_loaded VALUE={params.VALUE|int}

# You shouldn't call this directly, call CHECK_FILAMENT, which updates the endstop state
[gcode_macro UPDATE_FILAMENT]
gcode:
    {% if printer.query_endstops.last_query["manual_stepper gear_stepper"] == 0 %}
       S_F_L VALUE=1
    {% else %}
       S_F_L VALUE=0
    {% endif %}

[gcode_macro UPDATE_STATE]
gcode:
    QUERY_ENDSTOPS
    UPDATE_FILAMENT

[gcode_macro DUMP_STATE]
gcode:
    M118 Selector Target: {printer["gcode_macro VARS_MMU2"].selector_target}
    M118 Selector Index: {printer["gcode_macro VARS_MMU2"].selector_index}
    M118 Idler Target: {printer["gcode_macro VARS_MMU2"].idler_target}
    M118 Idler Index: {printer["gcode_macro VARS_MMU2"].idler_index}
    M118 Filament Loaded: {printer["gcode_macro VARS_MMU2"].filament_loaded}

[gcode_macro SLEEP_MOTORS]
gcode:
    MANUAL_STEPPER STEPPER=selector_stepper ENABLE=0
    MANUAL_STEPPER STEPPER=idler_stepper ENABLE=0
    MANUAL_STEPPER STEPPER=gear_stepper ENABLE=0

[gcode_macro _HOME_SELECTOR]
gcode:
    {% if printer["gcode_macro VARS_MMU2"].filament_loaded|int == 0 %}
        M118 Homing selector
        S_S_T VALUE=-1 
        MANUAL_STEPPER STEPPER=selector_stepper SET_POSITION=76
        MANUAL_STEPPER STEPPER=selector_stepper MOVE=0 STOP_ON_ENDSTOP=1
        MANUAL_STEPPER STEPPER=selector_stepper SET_POSITION=0
        S_S_T VALUE=5
        S_S_I VALUE=-1
    {% else %}
        {% if printer["gcode_macro VARS_MMU2"].filament_loaded|int == 1 %}
            M118 Not moving selector, filament loaded
        {% else %}
            M118 Not moving selector, filament state unknown
        {% endif %}
    {% endif %}

[gcode_macro HOME_SELECTOR]
gcode:
    UPDATE_STATE
    _HOME_SELECTOR

[gcode_macro _HOME_IDLER]
gcode:
    {% if printer["gcode_macro VARS_MMU2"].filament_loaded|int == 0 %}
        M118 Homing idler
        S_I_T VALUE=-1
        MANUAL_STEPPER STEPPER=idler_stepper SET_POSITION=236
        MANUAL_STEPPER STEPPER=idler_stepper MOVE=0 STOP_ON_ENDSTOP=1
        MANUAL_STEPPER STEPPER=idler_stepper SET_POSITION=0
        S_I_T VALUE=5
        S_I_I VALUE=-1
    {% else %}
        {% if printer["gcode_macro VARS_MMU2"].filament_loaded|int == 1 %}
            M118 Not moving idler, filament loaded
        {% else %}
            M118 Not moving idler, filament state unknown
        {% endif %}
    {% endif %}

[gcode_macro HOME_IDLER]
gcode:
    UPDATE_STATE
    _HOME_IDLER

[gcode_macro _MOVE_IDLER]
gcode:
    {% if printer["gcode_macro VARS_MMU2"].idler_index|int == 5 %}
        M118 Not moving idler. Not homed.  Use 'HOME_IDLER'.
    {% else %}
        {% if printer["gcode_macro VARS_MMU2"].filament_loaded|int == 0 %}
            M118 Moving Idler to {params.INDEX|int}
            S_I_T VALUE={params.INDEX|int} 
            MANUAL_STEPPER STEPPER=idler_stepper MOVE={printer["gcode_macro VARS_MMU2"].idler_positions[params.INDEX|int]}
            S_I_T VALUE=5
            S_I_I VALUE={params.INDEX|int}
        {% else %}
            {% if printer["gcode_macro VARS_MMU2"].filament_loaded|int == 1 %}
                M118 Not moving idler, filament loaded
            {% else %}
                M118 Not moving idler, filament state unknown
            {% endif %}
        {% endif %}
    {% endif %}

[gcode_macro MOVE_IDLER]
gcode:
    UPDATE_STATE
    _MOVE_IDLER INDEX={params.INDEX|int}
    
[gcode_macro _MOVE_SELECTOR]
gcode:
    {% if printer["gcode_macro VARS_MMU2"].selector_index|int == 5 %}
        M118 Not moving selector. Not homed. Use 'HOME_SELECTOR'
    {% else %}
        {% if printer["gcode_macro VARS_MMU2"].filament_loaded|int == 0 %}
            M118 Moving Selector to {params.INDEX|int}
            S_S_T VALUE={params.INDEX|int} 
            MANUAL_STEPPER STEPPER=selector_stepper MOVE={printer["gcode_macro VARS_MMU2"].selector_positions[params.INDEX|int]}
            S_S_T VALUE=5
            S_S_I VALUE={params.INDEX|int}
        {% else %}
            {% if printer["gcode_macro VARS_MMU2"].filament_loaded|int == 1 %}
                M118 Not moving selector, filament loaded
            {% else %}
                M118 Not moving selector, filament state unknown
            {% endif %}
        {% endif %}
    {% endif %}

[gcode_macro MOVE_SELECTOR]
gcode:
    UPDATE_STATE
    _MOVE_SELECTOR INDEX={params.INDEX|int}

[output_pin LEDG0]
pin: mmu2:SR8
value: 0

[output_pin LEDR0]
pin: mmu2:SR9
value: 0

[output_pin LEDG1]
pin: mmu2:SR10
value: 0

[output_pin LEDR1]
pin: mmu2:SR11
value: 0

[output_pin LEDG2]
pin: mmu2:SR12
value: 0

[output_pin LEDR2]
pin: mmu2:SR13
value: 0

[output_pin LEDG3]
pin: mmu2:SR14
value: 0

[output_pin LEDR3]
pin: mmu2:SR15
value: 0

[output_pin LEDG4]
pin: mmu2:SR6
value: 0

[output_pin LEDR4]
pin: mmu2:SR7
value: 0

#IR
#[filament_switch_sensor ir_sensor]
#pause_on_runout: False
#switch_pin: mmu2:PF6 # P1.28 for X-max

[gcode_macro RAINBOW]
gcode:
    SET_PIN PIN=LEDG0 value=1
    G4 P50
    SET_PIN PIN=LEDG1 value=1
    G4 P50
    SET_PIN PIN=LEDG0 value=0
    G4 P50
    SET_PIN PIN=LEDG2 value=1
    G4 P50
    SET_PIN PIN=LEDG1 value=0
    G4 P50
    SET_PIN PIN=LEDG3 value=1
    G4 P50
    SET_PIN PIN=LEDG2 value=0
    G4 P50
    SET_PIN PIN=LEDG4 value=1
    G4 P50
    SET_PIN PIN=LEDG3 value=0
    G4 P50
    SET_PIN PIN=LEDG4 value=0
    G4 P100
    # End, reversing
    SET_PIN PIN=LEDR4 value=1
    G4 P50
    SET_PIN PIN=LEDR3 value=1
    G4 P50
    SET_PIN PIN=LEDR4 value=0
    G4 P50
    SET_PIN PIN=LEDR2 value=1
    G4 P50
    SET_PIN PIN=LEDR3 value=0
    G4 P50
    SET_PIN PIN=LEDR1 value=1
    G4 P50
    SET_PIN PIN=LEDR2 value=0
    G4 P50
    SET_PIN PIN=LEDR0 value=1
    G4 P50
    SET_PIN PIN=LEDR1 value=0
    G4 P50
    SET_PIN PIN=LEDR0 value=0
    

###############################################
